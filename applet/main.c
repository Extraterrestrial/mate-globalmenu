/* main.c generated by valac, the Vala compiler
 * generated from main.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <configmake.h>
#include <gtk/gtk.h>
#include <matecomponent-activation/matecomponent-activation-init.h>
#include <matecomponent/matecomponent-main.h>
#include <mate-panel-applet.h>

#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define TYPE_APPLET (applet_get_type ())
#define APPLET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLET, GlobalMenuMatePanelApplet))
#define APPLET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLET, GlobalMenuMatePanelAppletClass))
#define IS_APPLET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLET))
#define IS_APPLET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLET))
#define APPLET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLET, GlobalMenuMatePanelAppletClass))

typedef struct _GlobalMenuMatePanelApplet GlobalMenuMatePanelApplet;
typedef struct _GlobalMenuMatePanelAppletClass GlobalMenuMatePanelAppletClass;


extern gboolean verbose;
gboolean verbose = FALSE;

#define FACTORY_IID "OAFIID:GlobalMenu_MatePanelApplet_Factory"
static void _lambda7_ (const char* domain, GLogLevelFlags level, const char* message);
static void __lambda7__glog_func (const char* log_domain, GLogLevelFlags log_levels, const char* message, gpointer self);
GType applet_get_type (void) G_GNUC_CONST;
#define APPLET_IID "OAFIID:GlobalMenu_MatePanelApplet"
void applet_init (GlobalMenuMatePanelApplet* self);
static gboolean _lambda8_ (MatePanelApplet* applet, const char* iid);
static gboolean __lambda8__mate_panel_applet_factory_callback (MatePanelApplet* applet, const char* iid, gpointer self);
gint _vala_main (char** args, int args_length1);
static int _vala_strcmp0 (const char * str1, const char * str2);

const GOptionEntry options[2] = {{"verbose", 'v', 0, G_OPTION_ARG_NONE, &verbose, N_ ("Be verbose"), NULL}, {NULL}};


static void _lambda7_ (const char* domain, GLogLevelFlags level, const char* message) {
	g_return_if_fail (message != NULL);
}


static void __lambda7__glog_func (const char* log_domain, GLogLevelFlags log_levels, const char* message, gpointer self) {
	_lambda7_ (log_domain, log_levels, message);
}


static gboolean _lambda8_ (MatePanelApplet* applet, const char* iid) {
	gboolean result = FALSE;
	g_return_val_if_fail (applet != NULL, FALSE);
	g_return_val_if_fail (iid != NULL, FALSE);
	if (_vala_strcmp0 (iid, APPLET_IID) == 0) {
		MatePanelApplet* _tmp0_;
		applet_init ((_tmp0_ = applet, IS_APPLET (_tmp0_) ? ((GlobalMenuMatePanelApplet*) _tmp0_) : NULL));
		gtk_widget_show ((GtkWidget*) applet);
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gboolean __lambda8__mate_panel_applet_factory_callback (MatePanelApplet* applet, const char* iid, gpointer self) {
	gboolean result;
	result = _lambda8_ (applet, iid);
	return result;
}


gint _vala_main (char** args, int args_length1) {
	gint result = 0;
	GError * _inner_error_;
	GOptionContext* context;
	gint retval;
	_inner_error_ = NULL;
	g_setenv ("GLOBALMENU_MATE_ARGS", "--disable", TRUE);
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	context = g_option_context_new ("- GlobalMenu.MatePanelApplet");
	g_option_context_set_help_enabled (context, TRUE);
	g_option_context_add_main_entries (context, options, NULL);
	g_option_context_add_group (context, gtk_get_option_group (TRUE));
	g_option_context_add_group (context, matecomponent_activation_get_goption_group ());
	{
		g_option_context_parse (context, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch20_g_error;
		}
	}
	goto __finally20;
	__catch20_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_error ("main.vala:25: parsing options failed: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally20:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	if (!verbose) {
		GLogFunc _tmp0_;
		GDestroyNotify handler_target_destroy_notify = NULL;
		void* handler_target = NULL;
		GLogFunc handler;
		handler = (_tmp0_ = __lambda7__glog_func, handler_target = NULL, handler_target_destroy_notify = NULL, _tmp0_);
		g_log_set_handler ("libmatenu", G_LOG_LEVEL_DEBUG, handler, handler_target);
		g_log_set_handler (NULL, G_LOG_LEVEL_DEBUG, handler, handler_target);
		(handler_target_destroy_notify == NULL) ? NULL : (handler_target_destroy_notify (handler_target), NULL);
		handler = NULL;
		handler_target = NULL;
		handler_target_destroy_notify = NULL;
	}
	gtk_rc_parse_string ("\n" \
"\t\tstyle \"globalmenu_event_box_style\"\n" \
"\t\t{\n" \
"\t\t\tGtkWidget::focus-line-width=0\n" \
"\t\t\tGtkWidget::focus-padding=0\n" \
"\t\t}\n" \
"\t\tstyle \"globalmenu_menu_bar_style\"\n" \
"\t\t{\n" \
"\t\t\tythickness = 0\n" \
"\t\t\tGtkMenuBar::shadow-type = none\n" \
"\t\t\tGtkMenuBar::internal-padding = 0\n" \
"\t\t}\n" \
"\t\tclass \"GtkEventBox\" style \"globalmenu_event_box_style\"\n" \
"\t\tclass \"MatenuMenuBar\" style:highest \"globalmenu_menu_bar_style" \
"\"\n");
	gtk_init (&args_length1, &args);
	if (!matecomponent_init (&args_length1, args)) {
		g_error ("main.vala:52: Cannot initialize matecomponent.");
	}
	retval = mate_panel_applet_factory_main (FACTORY_IID, TYPE_APPLET, __lambda8__mate_panel_applet_factory_callback, NULL);
	result = retval;
	_g_option_context_free0 (context);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




