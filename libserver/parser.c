/* parser.c generated by valac, the Vala compiler
 * generated from parser.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define MATENU_TYPE_PARSER (matenu_parser_get_type ())
#define MATENU_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MATENU_TYPE_PARSER, MatenuParser))
#define MATENU_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MATENU_TYPE_PARSER, MatenuParserClass))
#define MATENU_IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MATENU_TYPE_PARSER))
#define MATENU_IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MATENU_TYPE_PARSER))
#define MATENU_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MATENU_TYPE_PARSER, MatenuParserClass))

typedef struct _MatenuParser MatenuParser;
typedef struct _MatenuParserClass MatenuParserClass;
typedef struct _MatenuParserPrivate MatenuParserPrivate;

#define MATENU_PARSER_TYPE_STATE (matenu_parser_state_get_type ())
#define MATENU_PARSER_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MATENU_PARSER_TYPE_STATE, MatenuParserState))
#define MATENU_PARSER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MATENU_PARSER_TYPE_STATE, MatenuParserStateClass))
#define MATENU_PARSER_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MATENU_PARSER_TYPE_STATE))
#define MATENU_PARSER_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MATENU_PARSER_TYPE_STATE))
#define MATENU_PARSER_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MATENU_PARSER_TYPE_STATE, MatenuParserStateClass))

typedef struct _MatenuParserState MatenuParserState;
typedef struct _MatenuParserStateClass MatenuParserStateClass;
#define _g_queue_free0(var) ((var == NULL) ? NULL : (var = (g_queue_free (var), NULL)))

#define MATENU_TYPE_SHELL (matenu_shell_get_type ())
#define MATENU_SHELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MATENU_TYPE_SHELL, MatenuShell))
#define MATENU_IS_SHELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MATENU_TYPE_SHELL))
#define MATENU_SHELL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MATENU_TYPE_SHELL, MatenuShellIface))

typedef struct _MatenuShell MatenuShell;
typedef struct _MatenuShellIface MatenuShellIface;

#define MATENU_TYPE_ITEM (matenu_item_get_type ())
#define MATENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MATENU_TYPE_ITEM, MatenuItem))
#define MATENU_IS_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MATENU_TYPE_ITEM))
#define MATENU_ITEM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MATENU_TYPE_ITEM, MatenuItemIface))

typedef struct _MatenuItem MatenuItem;
typedef struct _MatenuItemIface MatenuItemIface;

#define MATENU_TYPE_ITEM_TYPE (matenu_item_type_get_type ())

#define MATENU_TYPE_ITEM_STATE (matenu_item_state_get_type ())
#define _g_markup_parse_context_free0(var) ((var == NULL) ? NULL : (var = (g_markup_parse_context_free (var), NULL)))
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _matenu_parser_unref0(var) ((var == NULL) ? NULL : (var = (matenu_parser_unref (var), NULL)))
#define _matenu_parser_state_unref0(var) ((var == NULL) ? NULL : (var = (matenu_parser_state_unref (var), NULL)))
typedef struct _MatenuParserStatePrivate MatenuParserStatePrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _MatenuParserParamSpecState MatenuParserParamSpecState;
typedef struct _MatenuParamSpecParser MatenuParamSpecParser;

struct _MatenuParser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MatenuParserPrivate * priv;
};

struct _MatenuParserClass {
	GTypeClass parent_class;
	void (*finalize) (MatenuParser *self);
};

struct _MatenuParserPrivate {
	GQueue* stack;
	gboolean is_bootstrapping;
};

typedef enum  {
	MATENU_ITEM_TYPE_NORMAL = 0,
	MATENU_ITEM_TYPE_CHECK = 1,
	MATENU_ITEM_TYPE_RADIO = 2,
	MATENU_ITEM_TYPE_IMAGE = 3,
	MATENU_ITEM_TYPE_SEPARATOR = 4,
	MATENU_ITEM_TYPE_ARROW = 5,
	MATENU_ITEM_TYPE_ICON = 6
} MatenuItemType;

typedef enum  {
	MATENU_ITEM_STATE_UNTOGGLED = 0,
	MATENU_ITEM_STATE_TOGGLED = 1,
	MATENU_ITEM_STATE_TRISTATE = 2
} MatenuItemState;

struct _MatenuItemIface {
	GTypeInterface parent_iface;
	MatenuShell* (*get_shell) (MatenuItem* self);
	MatenuShell* (*get_sub_shell) (MatenuItem* self);
	gboolean (*get_has_sub_shell) (MatenuItem* self);
	void (*set_has_sub_shell) (MatenuItem* self, gboolean value);
	gboolean (*get_client_side_sub_shell) (MatenuItem* self);
	void (*set_client_side_sub_shell) (MatenuItem* self, gboolean value);
	const char* (*get_item_id) (MatenuItem* self);
	void (*set_item_id) (MatenuItem* self, const char* value);
	MatenuItemType (*get_item_type) (MatenuItem* self);
	void (*set_item_type) (MatenuItem* self, MatenuItemType value);
	gboolean (*get_item_use_underline) (MatenuItem* self);
	void (*set_item_use_underline) (MatenuItem* self, gboolean value);
	gboolean (*get_item_sensitive) (MatenuItem* self);
	void (*set_item_sensitive) (MatenuItem* self, gboolean value);
	gboolean (*get_item_visible) (MatenuItem* self);
	void (*set_item_visible) (MatenuItem* self, gboolean value);
	MatenuItemState (*get_item_state) (MatenuItem* self);
	void (*set_item_state) (MatenuItem* self, MatenuItemState value);
	const char* (*get_item_label) (MatenuItem* self);
	void (*set_item_label) (MatenuItem* self, const char* value);
	const char* (*get_item_icon) (MatenuItem* self);
	void (*set_item_icon) (MatenuItem* self, const char* value);
	const char* (*get_item_accel_text) (MatenuItem* self);
	void (*set_item_accel_text) (MatenuItem* self, const char* value);
	const char* (*get_item_font) (MatenuItem* self);
	void (*set_item_font) (MatenuItem* self, const char* value);
};

struct _MatenuShellIface {
	GTypeInterface parent_iface;
	MatenuItem* (*get_item) (MatenuShell* self, gint position);
	MatenuItem* (*get_item_by_id) (MatenuShell* self, const char* id);
	gint (*get_item_position) (MatenuShell* self, MatenuItem* item);
	MatenuItem* (*get_owner) (MatenuShell* self);
	gint (*get_length) (MatenuShell* self);
	void (*set_length) (MatenuShell* self, gint value);
};

struct _MatenuParserState {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MatenuParserStatePrivate * priv;
	MatenuShell* shell;
	gboolean item_has_sub_shell;
};

struct _MatenuParserStateClass {
	GTypeClass parent_class;
	void (*finalize) (MatenuParserState *self);
};

struct _MatenuParserStatePrivate {
	gint _position;
};

struct _MatenuParserParamSpecState {
	GParamSpec parent_instance;
};

struct _MatenuParamSpecParser {
	GParamSpec parent_instance;
};


static gpointer matenu_parser_state_parent_class = NULL;
static gpointer matenu_parser_parent_class = NULL;

gpointer matenu_parser_ref (gpointer instance);
void matenu_parser_unref (gpointer instance);
GParamSpec* matenu_param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void matenu_value_set_parser (GValue* value, gpointer v_object);
void matenu_value_take_parser (GValue* value, gpointer v_object);
gpointer matenu_value_get_parser (const GValue* value);
GType matenu_parser_get_type (void) G_GNUC_CONST;
static gpointer matenu_parser_state_ref (gpointer instance);
static void matenu_parser_state_unref (gpointer instance);
static GParamSpec* matenu_parser_param_spec_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void matenu_parser_value_set_state (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void matenu_parser_value_take_state (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer matenu_parser_value_get_state (const GValue* value) G_GNUC_UNUSED;
static GType matenu_parser_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define MATENU_PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MATENU_TYPE_PARSER, MatenuParserPrivate))
enum  {
	MATENU_PARSER_DUMMY_PROPERTY
};
static void matenu_parser_start_element (MatenuParser* self, GMarkupParseContext* context, const char* element_name, char** attribute_names, int attribute_names_length1, char** attribute_values, int attribute_values_length1, GError** error);
static void _matenu_parser_start_element_gmarkup_parser_start_element_func (GMarkupParseContext* context, const char* element_name, char** attribute_names, char** attribute_values, gpointer self, GError** error);
static void matenu_parser_end_element (MatenuParser* self, GMarkupParseContext* context, const char* element_name, GError** error);
static void _matenu_parser_end_element_gmarkup_parser_end_element_func (GMarkupParseContext* context, const char* element_name, gpointer self, GError** error);
GType matenu_item_type_get_type (void) G_GNUC_CONST;
GType matenu_item_state_get_type (void) G_GNUC_CONST;
GType matenu_item_get_type (void) G_GNUC_CONST;
GType matenu_shell_get_type (void) G_GNUC_CONST;
static MatenuParser* matenu_parser_new (MatenuShell* shell);
static MatenuParser* matenu_parser_construct (GType object_type, MatenuShell* shell);
void matenu_parser_parse (MatenuShell* shell, const char* description, GError** error);
static MatenuParserState* matenu_parser_state_new (MatenuShell* shell);
static MatenuParserState* matenu_parser_state_construct (GType object_type, MatenuShell* shell);
static MatenuParserState* matenu_parser_get_state (MatenuParser* self);
static MatenuItem* matenu_parser_state_get_item (MatenuParserState* self);
MatenuShell* matenu_item_get_sub_shell (MatenuItem* self);
static void matenu_parser_setup_item (MatenuParser* self, MatenuItem* item, char** attr_names, int attr_names_length1, char** attr_vals, int attr_vals_length1, GError** error);
void matenu_item_set_item_id (MatenuItem* self, const char* value);
void matenu_item_set_item_visible (MatenuItem* self, gboolean value);
void matenu_item_set_item_use_underline (MatenuItem* self, gboolean value);
void matenu_item_set_item_sensitive (MatenuItem* self, gboolean value);
MatenuItemType matenu_item_type_from_string (const char* str);
void matenu_item_set_item_type (MatenuItem* self, MatenuItemType value);
void matenu_item_set_item_accel_text (MatenuItem* self, const char* value);
void matenu_item_set_item_label (MatenuItem* self, const char* value);
void matenu_item_set_item_icon (MatenuItem* self, const char* value);
MatenuItemState matenu_item_state_from_string (const char* str);
void matenu_item_set_item_state (MatenuItem* self, MatenuItemState value);
void matenu_item_set_item_font (MatenuItem* self, const char* value);
void matenu_item_set_client_side_sub_shell (MatenuItem* self, gboolean value);
static gint matenu_parser_state_get_position (MatenuParserState* self);
void matenu_shell_set_length (MatenuShell* self, gint value);
void matenu_item_set_has_sub_shell (MatenuItem* self, gboolean value);
static void matenu_parser_state_advance (MatenuParserState* self);
#define MATENU_PARSER_STATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MATENU_PARSER_TYPE_STATE, MatenuParserStatePrivate))
enum  {
	MATENU_PARSER_STATE_DUMMY_PROPERTY
};
MatenuItem* matenu_shell_get_item (MatenuShell* self, gint position);
static void matenu_parser_state_finalize (MatenuParserState* obj);
static void matenu_parser_finalize (MatenuParser* obj);
static gint _vala_array_length (gpointer array);

static const GMarkupParser MATENU_PARSER_parser_functions = {_matenu_parser_start_element_gmarkup_parser_start_element_func, _matenu_parser_end_element_gmarkup_parser_end_element_func, NULL, NULL, NULL};


static void _matenu_parser_start_element_gmarkup_parser_start_element_func (GMarkupParseContext* context, const char* element_name, char** attribute_names, char** attribute_values, gpointer self, GError** error) {
	matenu_parser_start_element (self, context, element_name, attribute_names, _vala_array_length (attribute_names), attribute_values, _vala_array_length (attribute_values), error);
}


static void _matenu_parser_end_element_gmarkup_parser_end_element_func (GMarkupParseContext* context, const char* element_name, gpointer self, GError** error) {
	matenu_parser_end_element (self, context, element_name, error);
}


void matenu_parser_parse (MatenuShell* shell, const char* description, GError** error) {
	GError * _inner_error_;
	MatenuParser* parser;
	GTimer* timer;
	GMarkupParseContext* context;
	g_return_if_fail (shell != NULL);
	g_return_if_fail (description != NULL);
	_inner_error_ = NULL;
	parser = matenu_parser_new (shell);
	timer = g_timer_new ();
	context = g_markup_parse_context_new (&MATENU_PARSER_parser_functions, 0, parser, NULL);
	g_markup_parse_context_parse (context, description, (gssize) (-1), &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_markup_parse_context_free0 (context);
		_g_timer_destroy0 (timer);
		_matenu_parser_unref0 (parser);
		return;
	}
	g_debug ("parser.vala:13: Parser consumed: %lf for %lu bytes", g_timer_elapsed (timer, NULL), (gulong) strlen (description));
	_g_markup_parse_context_free0 (context);
	_g_timer_destroy0 (timer);
	_matenu_parser_unref0 (parser);
}


static gpointer _matenu_parser_state_ref0 (gpointer self) {
	return self ? matenu_parser_state_ref (self) : NULL;
}


static MatenuParser* matenu_parser_construct (GType object_type, MatenuShell* shell) {
	MatenuParser* self;
	GQueue* _tmp0_;
	MatenuParserState* bootstrap;
	g_return_val_if_fail (shell != NULL, NULL);
	self = (MatenuParser*) g_type_create_instance (object_type);
	self->priv->stack = (_tmp0_ = g_queue_new (), _g_queue_free0 (self->priv->stack), _tmp0_);
	bootstrap = matenu_parser_state_new (shell);
	self->priv->is_bootstrapping = TRUE;
	g_queue_push_tail (self->priv->stack, _matenu_parser_state_ref0 (bootstrap));
	_matenu_parser_state_unref0 (bootstrap);
	return self;
}


static MatenuParser* matenu_parser_new (MatenuShell* shell) {
	return matenu_parser_construct (MATENU_TYPE_PARSER, shell);
}


static void matenu_parser_start_element (MatenuParser* self, GMarkupParseContext* context, const char* element_name, char** attribute_names, int attribute_names_length1, char** attribute_values, int attribute_values_length1, GError** error) {
	GError * _inner_error_;
	GQuark _tmp1_;
	const char* _tmp0_;
	static GQuark _tmp1__label0 = 0;
	static GQuark _tmp1__label1 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (element_name != NULL);
	_inner_error_ = NULL;
	_tmp0_ = element_name;
	_tmp1_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp1_ == ((0 != _tmp1__label0) ? _tmp1__label0 : (_tmp1__label0 = g_quark_from_static_string ("menu"))))
	switch (0) {
		default:
		{
			if (!self->priv->is_bootstrapping) {
				MatenuItem* item;
				item = matenu_parser_state_get_item (matenu_parser_get_state (self));
				matenu_parser_get_state (self)->item_has_sub_shell = TRUE;
				g_queue_push_tail (self->priv->stack, matenu_parser_state_new (matenu_item_get_sub_shell (item)));
				_g_object_unref0 (item);
			}
			break;
		}
	} else if (_tmp1_ == ((0 != _tmp1__label1) ? _tmp1__label1 : (_tmp1__label1 = g_quark_from_static_string ("item"))))
	switch (0) {
		default:
		{
			MatenuItem* item;
			self->priv->is_bootstrapping = FALSE;
			item = matenu_parser_state_get_item (matenu_parser_get_state (self));
			matenu_parser_setup_item (self, item, attribute_names, attribute_names_length1, attribute_values, attribute_values_length1, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_MARKUP_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (item);
					return;
				} else {
					_g_object_unref0 (item);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			matenu_parser_get_state (self)->item_has_sub_shell = FALSE;
			_g_object_unref0 (item);
			break;
		}
	} else
	switch (0) {
		default:
		{
			_inner_error_ = g_error_new_literal (G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT, "unknown element");
			{
				if (_inner_error_->domain == G_MARKUP_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static void matenu_parser_setup_item (MatenuParser* self, MatenuItem* item, char** attr_names, int attr_names_length1, char** attr_vals, int attr_vals_length1, GError** error) {
	GError * _inner_error_;
	const char* label;
	const char* icon;
	const char* type;
	const char* state;
	const char* font;
	const char* id;
	const char* accel;
	gboolean sensitive;
	gboolean visible;
	gboolean underline;
	gboolean client_side;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_inner_error_ = NULL;
	label = NULL;
	icon = NULL;
	type = NULL;
	state = NULL;
	font = NULL;
	id = NULL;
	accel = NULL;
	sensitive = TRUE;
	visible = TRUE;
	underline = TRUE;
	client_side = FALSE;
	g_markup_collect_attributes ("item", attr_names, attr_vals, &_inner_error_, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "label", &label, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "type", &type, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "state", &state, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "font", &font, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "id", &id, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "icon", &icon, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "accel", &accel, G_MARKUP_COLLECT_TRISTATE, "visible", &visible, G_MARKUP_COLLECT_TRISTATE, "underline", &underline, G_MARKUP_COLLECT_TRISTATE, "sensitive", &sensitive, G_MARKUP_COLLECT_TRISTATE, "client-side", &client_side, G_MARKUP_COLLECT_INVALID);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	if (visible != FALSE) {
		visible = TRUE;
	}
	if (sensitive != FALSE) {
		sensitive = TRUE;
	}
	if (underline != FALSE) {
		underline = TRUE;
	}
	if (client_side != TRUE) {
		client_side = FALSE;
	}
	matenu_item_set_item_id (item, id);
	matenu_item_set_item_visible (item, visible);
	matenu_item_set_item_use_underline (item, underline);
	matenu_item_set_item_sensitive (item, sensitive);
	matenu_item_set_item_type (item, matenu_item_type_from_string (type));
	matenu_item_set_item_accel_text (item, accel);
	matenu_item_set_item_label (item, label);
	matenu_item_set_item_icon (item, icon);
	matenu_item_set_item_state (item, matenu_item_state_from_string (state));
	matenu_item_set_item_font (item, font);
	matenu_item_set_client_side_sub_shell (item, client_side);
}


static void matenu_parser_end_element (MatenuParser* self, GMarkupParseContext* context, const char* element_name, GError** error) {
	GQuark _tmp4_;
	const char* _tmp3_;
	static GQuark _tmp4__label0 = 0;
	static GQuark _tmp4__label1 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (element_name != NULL);
	_tmp3_ = element_name;
	_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	if (_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("menu"))))
	switch (0) {
		default:
		{
			MatenuParserState* _tmp0_;
			matenu_shell_set_length (matenu_parser_get_state (self)->shell, matenu_parser_state_get_position (matenu_parser_get_state (self)));
			_tmp0_ = (MatenuParserState*) g_queue_pop_tail (self->priv->stack);
			_matenu_parser_state_unref0 (_tmp0_);
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("item"))))
	switch (0) {
		default:
		{
			if (!matenu_parser_get_state (self)->item_has_sub_shell) {
				MatenuItem* _tmp1_;
				matenu_item_set_has_sub_shell (_tmp1_ = matenu_parser_state_get_item (matenu_parser_get_state (self)), FALSE);
				_g_object_unref0 (_tmp1_);
			} else {
				MatenuItem* _tmp2_;
				matenu_item_set_has_sub_shell (_tmp2_ = matenu_parser_state_get_item (matenu_parser_get_state (self)), TRUE);
				_g_object_unref0 (_tmp2_);
			}
			matenu_parser_state_advance (matenu_parser_get_state (self));
			break;
		}
	}
}


static MatenuParserState* matenu_parser_get_state (MatenuParser* self) {
	MatenuParserState* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = (MatenuParserState*) g_queue_peek_tail (self->priv->stack);
	return result;
}


static void matenu_parser_state_advance (MatenuParserState* self) {
	g_return_if_fail (self != NULL);
	self->priv->_position++;
}


static MatenuItem* matenu_parser_state_get_item (MatenuParserState* self) {
	MatenuItem* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = matenu_shell_get_item (self->shell, matenu_parser_state_get_position (self));
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static MatenuParserState* matenu_parser_state_construct (GType object_type, MatenuShell* shell) {
	MatenuParserState* self;
	MatenuShell* _tmp0_;
	g_return_val_if_fail (shell != NULL, NULL);
	self = (MatenuParserState*) g_type_create_instance (object_type);
	self->shell = (_tmp0_ = _g_object_ref0 (shell), _g_object_unref0 (self->shell), _tmp0_);
	return self;
}


static MatenuParserState* matenu_parser_state_new (MatenuShell* shell) {
	return matenu_parser_state_construct (MATENU_PARSER_TYPE_STATE, shell);
}


static gint matenu_parser_state_get_position (MatenuParserState* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_position;
	return result;
}


static void matenu_parser_value_state_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void matenu_parser_value_state_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		matenu_parser_state_unref (value->data[0].v_pointer);
	}
}


static void matenu_parser_value_state_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = matenu_parser_state_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer matenu_parser_value_state_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* matenu_parser_value_state_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		MatenuParserState* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = matenu_parser_state_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* matenu_parser_value_state_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	MatenuParserState** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = matenu_parser_state_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* matenu_parser_param_spec_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	MatenuParserParamSpecState* spec;
	g_return_val_if_fail (g_type_is_a (object_type, MATENU_PARSER_TYPE_STATE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer matenu_parser_value_get_state (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MATENU_PARSER_TYPE_STATE), NULL);
	return value->data[0].v_pointer;
}


static void matenu_parser_value_set_state (GValue* value, gpointer v_object) {
	MatenuParserState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MATENU_PARSER_TYPE_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MATENU_PARSER_TYPE_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		matenu_parser_state_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		matenu_parser_state_unref (old);
	}
}


static void matenu_parser_value_take_state (GValue* value, gpointer v_object) {
	MatenuParserState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MATENU_PARSER_TYPE_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MATENU_PARSER_TYPE_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		matenu_parser_state_unref (old);
	}
}


static void matenu_parser_state_class_init (MatenuParserStateClass * klass) {
	matenu_parser_state_parent_class = g_type_class_peek_parent (klass);
	MATENU_PARSER_STATE_CLASS (klass)->finalize = matenu_parser_state_finalize;
	g_type_class_add_private (klass, sizeof (MatenuParserStatePrivate));
}


static void matenu_parser_state_instance_init (MatenuParserState * self) {
	self->priv = MATENU_PARSER_STATE_GET_PRIVATE (self);
	self->priv->_position = 0;
	self->item_has_sub_shell = FALSE;
	self->ref_count = 1;
}


static void matenu_parser_state_finalize (MatenuParserState* obj) {
	MatenuParserState * self;
	self = MATENU_PARSER_STATE (obj);
	_g_object_unref0 (self->shell);
}


static GType matenu_parser_state_get_type (void) {
	static volatile gsize matenu_parser_state_type_id__volatile = 0;
	if (g_once_init_enter (&matenu_parser_state_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { matenu_parser_value_state_init, matenu_parser_value_state_free_value, matenu_parser_value_state_copy_value, matenu_parser_value_state_peek_pointer, "p", matenu_parser_value_state_collect_value, "p", matenu_parser_value_state_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (MatenuParserStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) matenu_parser_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MatenuParserState), 0, (GInstanceInitFunc) matenu_parser_state_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType matenu_parser_state_type_id;
		matenu_parser_state_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MatenuParserState", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&matenu_parser_state_type_id__volatile, matenu_parser_state_type_id);
	}
	return matenu_parser_state_type_id__volatile;
}


static gpointer matenu_parser_state_ref (gpointer instance) {
	MatenuParserState* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void matenu_parser_state_unref (gpointer instance) {
	MatenuParserState* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MATENU_PARSER_STATE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void matenu_value_parser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void matenu_value_parser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		matenu_parser_unref (value->data[0].v_pointer);
	}
}


static void matenu_value_parser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = matenu_parser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer matenu_value_parser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* matenu_value_parser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		MatenuParser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = matenu_parser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* matenu_value_parser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	MatenuParser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = matenu_parser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* matenu_param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	MatenuParamSpecParser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, MATENU_TYPE_PARSER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer matenu_value_get_parser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MATENU_TYPE_PARSER), NULL);
	return value->data[0].v_pointer;
}


void matenu_value_set_parser (GValue* value, gpointer v_object) {
	MatenuParser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MATENU_TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MATENU_TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		matenu_parser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		matenu_parser_unref (old);
	}
}


void matenu_value_take_parser (GValue* value, gpointer v_object) {
	MatenuParser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MATENU_TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MATENU_TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		matenu_parser_unref (old);
	}
}


static void matenu_parser_class_init (MatenuParserClass * klass) {
	matenu_parser_parent_class = g_type_class_peek_parent (klass);
	MATENU_PARSER_CLASS (klass)->finalize = matenu_parser_finalize;
	g_type_class_add_private (klass, sizeof (MatenuParserPrivate));
}


static void matenu_parser_instance_init (MatenuParser * self) {
	self->priv = MATENU_PARSER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void matenu_parser_finalize (MatenuParser* obj) {
	MatenuParser * self;
	self = MATENU_PARSER (obj);
	{
		MatenuParserState* s;
		s = NULL;
		while (TRUE) {
			MatenuParserState* _tmp0_;
			if (!((s = (_tmp0_ = (MatenuParserState*) g_queue_pop_tail (self->priv->stack), _matenu_parser_state_unref0 (s), _tmp0_)) != NULL)) {
				break;
			}
			continue;
		}
		_matenu_parser_state_unref0 (s);
	}
	_g_queue_free0 (self->priv->stack);
}


GType matenu_parser_get_type (void) {
	static volatile gsize matenu_parser_type_id__volatile = 0;
	if (g_once_init_enter (&matenu_parser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { matenu_value_parser_init, matenu_value_parser_free_value, matenu_value_parser_copy_value, matenu_value_parser_peek_pointer, "p", matenu_value_parser_collect_value, "p", matenu_value_parser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (MatenuParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) matenu_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MatenuParser), 0, (GInstanceInitFunc) matenu_parser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType matenu_parser_type_id;
		matenu_parser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MatenuParser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&matenu_parser_type_id__volatile, matenu_parser_type_id);
	}
	return matenu_parser_type_id__volatile;
}


gpointer matenu_parser_ref (gpointer instance) {
	MatenuParser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void matenu_parser_unref (gpointer instance) {
	MatenuParser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MATENU_PARSER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




