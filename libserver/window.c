/* window.c generated by valac, the Vala compiler
 * generated from window.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <libwnck/libwnck.h>
#include <gdk/gdkx.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>


#define MATENU_TYPE_WINDOW (matenu_window_get_type ())
#define MATENU_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MATENU_TYPE_WINDOW, MatenuWindow))
#define MATENU_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MATENU_TYPE_WINDOW, MatenuWindowClass))
#define MATENU_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MATENU_TYPE_WINDOW))
#define MATENU_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MATENU_TYPE_WINDOW))
#define MATENU_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MATENU_TYPE_WINDOW, MatenuWindowClass))

typedef struct _MatenuWindow MatenuWindow;
typedef struct _MatenuWindowClass MatenuWindowClass;
typedef struct _MatenuWindowPrivate MatenuWindowPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _MatenuWindow {
	GObject parent_instance;
	MatenuWindowPrivate * priv;
};

struct _MatenuWindowClass {
	GObjectClass parent_class;
	void (*property_notify_event) (MatenuWindow* self, const char* prop);
};

struct _MatenuWindowPrivate {
	gint _monitor_num;
	GdkWindow* _window;
	GtkWidget* key_widget;
	gboolean disposed;
	MatenuWindow* _transient;
};


static gpointer matenu_window_parent_class = NULL;

GType matenu_window_get_type (void) G_GNUC_CONST;
#define MATENU_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MATENU_TYPE_WINDOW, MatenuWindowPrivate))
enum  {
	MATENU_WINDOW_DUMMY_PROPERTY,
	MATENU_WINDOW_WINDOW,
	MATENU_WINDOW_TRANSIENT
};
#define MATENU_WINDOW_WM_TRANSIENT_FOR "WM_TRANSIENT_FOR"
guint matenu_window_get_xid (MatenuWindow* self);
WnckWindow* matenu_window_get_wnck_window (MatenuWindow* self);
gboolean matenu_window_is_on_active_workspace (MatenuWindow* self);
gint matenu_window_get_monitor_num (MatenuWindow* self);
void matenu_window_set_window (MatenuWindow* self, GdkWindow* value);
static void matenu_window_recompute_monitor_num (MatenuWindow* self);
MatenuWindow* matenu_window_new (GdkWindow* window);
MatenuWindow* matenu_window_construct (GType object_type, GdkWindow* window);
MatenuWindow* matenu_window_foreign_new (gulong xid);
void matenu_window_set_key_widget (MatenuWindow* self, GtkWidget* widget);
static void matenu_window_real_dispose (GObject* base);
static GdkFilterReturn matenu_window_real_event_filter (XEvent* xevent, GdkEvent* event, MatenuWindow* self);
static GdkFilterReturn matenu_window_event_filter (GdkXEvent* xevent, GdkEvent* event, MatenuWindow* self);
Status XSendEvent (Display* display, Window target, gboolean flag, glong mask, XEvent* event);
#define MATENU_NET_GLOBALMENU_MENU_CONTEXT "_NET_GLOBALMENU_MENU_CONTEXT"
static MatenuWindow* matenu_window_get_rewire_target (MatenuWindow* self);
#define MATENU_NET_GLOBALMENU_MENU_EVENT "_NET_GLOBALMENU_MENU_EVENT"
char* matenu_window_get (MatenuWindow* self, const char* property_name);
#define MATENU_NET_GLOBALMENU_MENU_SELECT "_NET_GLOBALMENU_MENU_SELECT"
#define MATENU_NET_GLOBALMENU_MENU_DESELECT "_NET_GLOBALMENU_MENU_DESELECT"
static void matenu_window_rewire_globalmenu_events (MatenuWindow* self, const char* prop);
MatenuWindow* matenu_window_get_transient (MatenuWindow* self);
void matenu_window_set_transient (MatenuWindow* self, MatenuWindow* value);
static void matenu_window_recompute_transient (MatenuWindow* self);
char* matenu_window_get_by_atom (MatenuWindow* self, GdkAtom atom);
void matenu_window_set_by_atom (MatenuWindow* self, GdkAtom atom, const char* value);
void matenu_window_set (MatenuWindow* self, const char* property_name, const char* value);
GdkWindow* matenu_window_get_window (MatenuWindow* self);
char* matenu_window_get_menu_context (MatenuWindow* self);
void matenu_window_set_menu_context (MatenuWindow* self, const char* value);
void matenu_window_emit_menu_event (MatenuWindow* self, const char* path);
void matenu_window_emit_menu_select (MatenuWindow* self, const char* path, const char* pos);
void matenu_window_emit_menu_deselect (MatenuWindow* self, const char* path);
gboolean matenu_grab_key (GdkWindow* grab_window, guint keyval, GdkModifierType state);
gboolean matenu_window_grab_key (MatenuWindow* self, guint keyval, GdkModifierType state);
gboolean matenu_ungrab_key (GdkWindow* grab_window, guint keyval, GdkModifierType state);
gboolean matenu_window_ungrab_key (MatenuWindow* self, guint keyval, GdkModifierType state);
static GdkFilterReturn _matenu_window_event_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self);
void matenu_window_property_notify_event (MatenuWindow* self, const char* prop);
static void matenu_window_real_property_notify_event (MatenuWindow* self, const char* prop);
static void matenu_window_finalize (GObject* obj);
static void matenu_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void matenu_window_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);


static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


WnckWindow* matenu_window_get_wnck_window (MatenuWindow* self) {
	WnckWindow* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = _g_object_ref0 (wnck_window_get ((gulong) matenu_window_get_xid (self)));
	return result;
}


gboolean matenu_window_is_on_active_workspace (MatenuWindow* self) {
	gboolean result = FALSE;
	WnckWindow* wnck_window;
	WnckScreen* screen;
	WnckWorkspace* workspace;
	g_return_val_if_fail (self != NULL, FALSE);
	wnck_window = matenu_window_get_wnck_window (self);
	if (wnck_window == NULL) {
		result = TRUE;
		_g_object_unref0 (wnck_window);
		return result;
	}
	screen = _g_object_ref0 (wnck_window_get_screen (wnck_window));
	workspace = _g_object_ref0 (wnck_screen_get_active_workspace (screen));
	if (workspace == NULL) {
		result = TRUE;
		_g_object_unref0 (workspace);
		_g_object_unref0 (screen);
		_g_object_unref0 (wnck_window);
		return result;
	}
	result = wnck_window_is_on_workspace (wnck_window, workspace);
	_g_object_unref0 (workspace);
	_g_object_unref0 (screen);
	_g_object_unref0 (wnck_window);
	return result;
}


gint matenu_window_get_monitor_num (MatenuWindow* self) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_monitor_num;
	return result;
}


guint matenu_window_get_xid (MatenuWindow* self) {
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	if (self->priv->_window != NULL) {
		result = (guint) gdk_x11_drawable_get_xid ((GdkDrawable*) self->priv->_window);
		return result;
	}
	g_error ("window.vala:58: getting xid before _window has been initialized");
	result = (guint) 0;
	return result;
}


MatenuWindow* matenu_window_construct (GType object_type, GdkWindow* window) {
	MatenuWindow * self;
	g_return_val_if_fail (window != NULL, NULL);
	self = (MatenuWindow*) g_object_new (object_type, NULL);
	matenu_window_set_window (self, window);
	matenu_window_recompute_monitor_num (self);
	return self;
}


MatenuWindow* matenu_window_new (GdkWindow* window) {
	return matenu_window_construct (MATENU_TYPE_WINDOW, window);
}


MatenuWindow* matenu_window_foreign_new (gulong xid) {
	MatenuWindow* result = NULL;
	GdkWindow* gdk_window;
	GdkWindow* _tmp0_;
	gdk_window = NULL;
	gdk_window = (_tmp0_ = _g_object_ref0 (gdk_window_lookup ((GdkNativeWindow) xid)), _g_object_unref0 (gdk_window), _tmp0_);
	if (gdk_window == NULL) {
		GdkWindow* _tmp1_;
		gdk_window = (_tmp1_ = _g_object_ref0 (gdk_window_foreign_new ((GdkNativeWindow) xid)), _g_object_unref0 (gdk_window), _tmp1_);
	}
	if (gdk_window == NULL) {
		result = NULL;
		_g_object_unref0 (gdk_window);
		return result;
	}
	result = matenu_window_new (gdk_window);
	_g_object_unref0 (gdk_window);
	return result;
}


void matenu_window_set_key_widget (MatenuWindow* self, GtkWidget* widget) {
	GtkWidget* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->key_widget = (_tmp0_ = _g_object_ref0 (widget), _g_object_unref0 (self->priv->key_widget), _tmp0_);
}


static void matenu_window_real_dispose (GObject* base) {
	MatenuWindow * self;
	self = (MatenuWindow*) base;
	if (!self->priv->disposed) {
		self->priv->disposed = TRUE;
		matenu_window_set_window (self, NULL);
	}
}


static GdkFilterReturn matenu_window_event_filter (GdkXEvent* xevent, GdkEvent* event, MatenuWindow* self) {
	GdkFilterReturn result = 0;
	void* pointer;
	XEvent* e;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (event != NULL, 0);
	pointer = xevent;
	e = (XEvent*) pointer;
	result = matenu_window_real_event_filter (e, event, self);
	return result;
}


static GdkFilterReturn matenu_window_real_event_filter (XEvent* xevent, GdkEvent* event, MatenuWindow* self) {
	GdkFilterReturn result = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (event != NULL, 0);
	if (self->priv->disposed) {
		g_critical ("window.vala:102: event_filter invoked on a disposed window");
		result = GDK_FILTER_CONTINUE;
		return result;
	}
	switch ((*xevent).type) {
		case PropertyNotify:
		{
			char* name;
			name = gdk_atom_name (gdk_x11_xatom_to_atom ((*xevent).xproperty.atom));
			g_signal_emit_by_name (self, "property-notify-event", name);
			_g_free0 (name);
			break;
		}
		case KeyPress:
		{
			gboolean _tmp0_ = FALSE;
			Window new_target;
			Display* display;
			if (self->priv->key_widget == NULL) {
				_tmp0_ = TRUE;
			} else {
				_tmp0_ = self->priv->key_widget->window == NULL;
			}
			if (_tmp0_) {
				break;
			}
			new_target = (Window) gdk_x11_drawable_get_xid ((GdkDrawable*) self->priv->key_widget->window);
			display = (Display*) gdk_x11_drawable_get_xdisplay ((GdkDrawable*) self->priv->key_widget->window);
			(*xevent).xany.window = new_target;
			XSendEvent (display, new_target, FALSE, (glong) 0, xevent);
			break;
		}
		case ConfigureNotify:
		{
			matenu_window_recompute_monitor_num (self);
			break;
		}
	}
	result = GDK_FILTER_CONTINUE;
	return result;
}


static void matenu_window_rewire_globalmenu_events (MatenuWindow* self, const char* prop) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (prop != NULL);
	if (_vala_strcmp0 (prop, MATENU_NET_GLOBALMENU_MENU_CONTEXT) == 0) {
		g_debug ("window.vala:144: window (%p) prop menu context is reported changed", self);
		g_signal_emit_by_name (matenu_window_get_rewire_target (self), "menu-context-changed");
	} else {
		if (_vala_strcmp0 (prop, MATENU_NET_GLOBALMENU_MENU_EVENT) == 0) {
			char* _tmp0_;
			g_signal_emit_by_name (matenu_window_get_rewire_target (self), "menu-event", _tmp0_ = matenu_window_get (self, MATENU_NET_GLOBALMENU_MENU_EVENT));
			_g_free0 (_tmp0_);
		} else {
			if (_vala_strcmp0 (prop, MATENU_NET_GLOBALMENU_MENU_SELECT) == 0) {
				char* val;
				char** _tmp2_;
				gint _arr_size_;
				gint arr_length1;
				char** _tmp1_;
				char** arr;
				gboolean _tmp3_ = FALSE;
				val = matenu_window_get (self, MATENU_NET_GLOBALMENU_MENU_SELECT);
				arr = (_tmp2_ = _tmp1_ = g_strsplit (val, "@", 0), arr_length1 = _vala_array_length (_tmp1_), _arr_size_ = arr_length1, _tmp2_);
				if (arr != NULL) {
					_tmp3_ = arr_length1 >= 1;
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					g_signal_emit_by_name (matenu_window_get_rewire_target (self), "menu-select", arr[0], arr[1]);
				}
				arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (val);
			} else {
				if (_vala_strcmp0 (prop, MATENU_NET_GLOBALMENU_MENU_DESELECT) == 0) {
					char* val;
					val = matenu_window_get (self, MATENU_NET_GLOBALMENU_MENU_DESELECT);
					g_signal_emit_by_name (matenu_window_get_rewire_target (self), "menu-deselect", val);
					_g_free0 (val);
				}
			}
		}
	}
}


static void matenu_window_recompute_monitor_num (MatenuWindow* self) {
	GdkScreen* screen;
	gint old_num;
	g_return_if_fail (self != NULL);
	screen = _g_object_ref0 (gdk_drawable_get_screen ((GdkDrawable*) self->priv->_window));
	old_num = self->priv->_monitor_num;
	if (gdk_window_get_type_hint (self->priv->_window) == GDK_WINDOW_TYPE_HINT_DESKTOP) {
		self->priv->_monitor_num = -1;
	} else {
		self->priv->_monitor_num = gdk_screen_get_monitor_at_window (screen, self->priv->_window);
	}
	if (old_num != self->priv->_monitor_num) {
		g_signal_emit_by_name (self, "monitor-num-changed", old_num);
	}
	_g_object_unref0 (screen);
}


static void matenu_window_recompute_transient (MatenuWindow* self) {
	WnckWindow* wnck_window;
	MatenuWindow* old;
	WnckWindow* wnck_transient;
	g_return_if_fail (self != NULL);
	if (gdk_window_get_window_type (self->priv->_window) == GDK_WINDOW_ROOT) {
		return;
	}
	wnck_window = matenu_window_get_wnck_window (self);
	old = _g_object_ref0 (self->priv->_transient);
	if (wnck_window == NULL) {
		g_error ("window.vala:187: xwindow %u has been destroyed", matenu_window_get_xid (self));
		_g_object_unref0 (old);
		_g_object_unref0 (wnck_window);
		return;
	}
	wnck_transient = _g_object_ref0 (wnck_window_get_transient (wnck_window));
	if (wnck_transient == NULL) {
		matenu_window_set_transient (self, NULL);
	} else {
		gulong new_xid;
		gboolean _tmp0_ = FALSE;
		new_xid = wnck_window_get_xid (wnck_transient);
		if (old == NULL) {
			_tmp0_ = TRUE;
		} else {
			_tmp0_ = new_xid != matenu_window_get_xid (old);
		}
		if (_tmp0_) {
			MatenuWindow* _tmp1_;
			char* _tmp2_;
			matenu_window_set_transient (self, _tmp1_ = matenu_window_foreign_new (new_xid));
			_g_object_unref0 (_tmp1_);
			g_debug ("window.vala:197: transient-for changed to = '%s'", _tmp2_ = matenu_window_get (self->priv->_transient, "WM_CLASS"));
			_g_free0 (_tmp2_);
		}
	}
	_g_object_unref0 (wnck_transient);
	_g_object_unref0 (old);
	_g_object_unref0 (wnck_window);
}


char* matenu_window_get (MatenuWindow* self, const char* property_name) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (property_name != NULL, NULL);
	result = matenu_window_get_by_atom (self, gdk_atom_intern (property_name, FALSE));
	return result;
}


void matenu_window_set (MatenuWindow* self, const char* property_name, const char* value) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (property_name != NULL);
	matenu_window_set_by_atom (self, gdk_atom_intern (property_name, FALSE), value);
}


char* matenu_window_get_by_atom (MatenuWindow* self, GdkAtom atom) {
	char* result = NULL;
	char* context;
	GdkAtom actual_type;
	GdkAtom type;
	gint actual_format = 0;
	gint actual_length = 0;
	char* _tmp1_;
	char* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	context = NULL;
	type = gdk_atom_intern ("STRING", FALSE);
	gdk_property_get (matenu_window_get_window (self), atom, type, (gulong) 0, (gulong) G_MAXLONG, FALSE, &actual_type, &actual_format, &actual_length, &_tmp0_);
	context = (_tmp1_ = _tmp0_, _g_free0 (context), _tmp1_);
	result = context;
	return result;
}


void matenu_window_set_by_atom (MatenuWindow* self, GdkAtom atom, const char* value) {
	g_return_if_fail (self != NULL);
	if (value != NULL) {
		GdkAtom type;
		type = gdk_atom_intern ("STRING", FALSE);
		gdk_property_change (matenu_window_get_window (self), atom, type, 8, GDK_PROP_MODE_REPLACE, value, ((gint) strlen (value)) + 1);
	} else {
		gdk_property_delete (matenu_window_get_window (self), atom);
	}
}


char* matenu_window_get_menu_context (MatenuWindow* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = matenu_window_get (matenu_window_get_rewire_target (self), MATENU_NET_GLOBALMENU_MENU_CONTEXT);
	return result;
}


void matenu_window_set_menu_context (MatenuWindow* self, const char* value) {
	g_return_if_fail (self != NULL);
	matenu_window_set (matenu_window_get_rewire_target (self), MATENU_NET_GLOBALMENU_MENU_CONTEXT, value);
}


void matenu_window_emit_menu_event (MatenuWindow* self, const char* path) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	matenu_window_set (matenu_window_get_rewire_target (self), MATENU_NET_GLOBALMENU_MENU_EVENT, path);
}


void matenu_window_emit_menu_select (MatenuWindow* self, const char* path, const char* pos) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	if (pos != NULL) {
		char* _tmp1_;
		char* _tmp0_;
		matenu_window_set (matenu_window_get_rewire_target (self), MATENU_NET_GLOBALMENU_MENU_SELECT, _tmp1_ = g_strconcat (_tmp0_ = g_strconcat (path, "@", NULL), pos, NULL));
		_g_free0 (_tmp1_);
		_g_free0 (_tmp0_);
	} else {
		matenu_window_set (matenu_window_get_rewire_target (self), MATENU_NET_GLOBALMENU_MENU_SELECT, path);
	}
}


void matenu_window_emit_menu_deselect (MatenuWindow* self, const char* path) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	matenu_window_set (matenu_window_get_rewire_target (self), MATENU_NET_GLOBALMENU_MENU_DESELECT, path);
}


gboolean matenu_window_grab_key (MatenuWindow* self, guint keyval, GdkModifierType state) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = matenu_grab_key (matenu_window_get_window (self), keyval, state);
	return result;
}


gboolean matenu_window_ungrab_key (MatenuWindow* self, guint keyval, GdkModifierType state) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = matenu_ungrab_key (matenu_window_get_window (self), keyval, state);
	return result;
}


GdkWindow* matenu_window_get_window (MatenuWindow* self) {
	GdkWindow* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_window;
	return result;
}


static GdkFilterReturn _matenu_window_event_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self) {
	GdkFilterReturn result;
	result = matenu_window_event_filter (xevent, event, self);
	return result;
}


void matenu_window_set_window (MatenuWindow* self, GdkWindow* value) {
	GdkWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	if (self->priv->_window != NULL) {
		gdk_window_remove_filter (self->priv->_window, _matenu_window_event_filter_gdk_filter_func, self);
	}
	self->priv->_window = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_window), _tmp0_);
	if (self->priv->_window != NULL) {
		matenu_window_recompute_transient (self);
		gdk_window_add_filter (self->priv->_window, _matenu_window_event_filter_gdk_filter_func, self);
	}
	g_object_notify ((GObject *) self, "window");
}


static MatenuWindow* matenu_window_get_rewire_target (MatenuWindow* self) {
	MatenuWindow* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (self->priv->_transient != NULL) {
		result = matenu_window_get_rewire_target (self->priv->_transient);
		return result;
	} else {
		result = self;
		return result;
	}
}


MatenuWindow* matenu_window_get_transient (MatenuWindow* self) {
	MatenuWindow* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_transient;
	return result;
}


void matenu_window_set_transient (MatenuWindow* self, MatenuWindow* value) {
	MatenuWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_transient = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_transient), _tmp0_);
	g_object_notify ((GObject *) self, "transient");
}


static void matenu_window_real_property_notify_event (MatenuWindow* self, const char* prop) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (prop != NULL);
	if (_vala_strcmp0 (prop, MATENU_WINDOW_WM_TRANSIENT_FOR) == 0) {
		g_debug ("window.vala:134: transient property changed");
		matenu_window_recompute_transient (self);
		g_signal_emit_by_name (self, "menu-context-changed");
	} else {
		matenu_window_rewire_globalmenu_events (self, prop);
	}
}


static void matenu_window_class_init (MatenuWindowClass * klass) {
	matenu_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MatenuWindowPrivate));
	G_OBJECT_CLASS (klass)->dispose = matenu_window_real_dispose;
	MATENU_WINDOW_CLASS (klass)->property_notify_event = matenu_window_real_property_notify_event;
	G_OBJECT_CLASS (klass)->get_property = matenu_window_get_property;
	G_OBJECT_CLASS (klass)->set_property = matenu_window_set_property;
	G_OBJECT_CLASS (klass)->finalize = matenu_window_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MATENU_WINDOW_WINDOW, g_param_spec_object ("window", "window", "window", GDK_TYPE_WINDOW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MATENU_WINDOW_TRANSIENT, g_param_spec_object ("transient", "transient", "transient", MATENU_TYPE_WINDOW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("monitor_num_changed", MATENU_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("property_notify_event", MATENU_TYPE_WINDOW, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (MatenuWindowClass, property_notify_event), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("menu_context_changed", MATENU_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("menu_event", MATENU_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("menu_select", MATENU_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_STRING);
	g_signal_new ("menu_deselect", MATENU_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("transient_changed", MATENU_TYPE_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, MATENU_TYPE_WINDOW);
}


static void matenu_window_instance_init (MatenuWindow * self) {
	self->priv = MATENU_WINDOW_GET_PRIVATE (self);
	self->priv->_monitor_num = -1;
	self->priv->disposed = FALSE;
}


static void matenu_window_finalize (GObject* obj) {
	MatenuWindow * self;
	self = MATENU_WINDOW (obj);
	_g_object_unref0 (self->priv->_window);
	_g_object_unref0 (self->priv->key_widget);
	_g_object_unref0 (self->priv->_transient);
	G_OBJECT_CLASS (matenu_window_parent_class)->finalize (obj);
}


GType matenu_window_get_type (void) {
	static volatile gsize matenu_window_type_id__volatile = 0;
	if (g_once_init_enter (&matenu_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MatenuWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) matenu_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MatenuWindow), 0, (GInstanceInitFunc) matenu_window_instance_init, NULL };
		GType matenu_window_type_id;
		matenu_window_type_id = g_type_register_static (G_TYPE_OBJECT, "MatenuWindow", &g_define_type_info, 0);
		g_once_init_leave (&matenu_window_type_id__volatile, matenu_window_type_id);
	}
	return matenu_window_type_id__volatile;
}


static void matenu_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	MatenuWindow * self;
	self = MATENU_WINDOW (object);
	switch (property_id) {
		case MATENU_WINDOW_WINDOW:
		g_value_set_object (value, matenu_window_get_window (self));
		break;
		case MATENU_WINDOW_TRANSIENT:
		g_value_set_object (value, matenu_window_get_transient (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void matenu_window_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	MatenuWindow * self;
	self = MATENU_WINDOW (object);
	switch (property_id) {
		case MATENU_WINDOW_WINDOW:
		matenu_window_set_window (self, g_value_get_object (value));
		break;
		case MATENU_WINDOW_TRANSIENT:
		matenu_window_set_transient (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}



static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), data2);
}



